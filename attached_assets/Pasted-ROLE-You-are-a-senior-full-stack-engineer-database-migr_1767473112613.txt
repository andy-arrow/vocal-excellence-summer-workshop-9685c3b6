ROLE: You are a senior full-stack engineer + database migration lead.

MISSION:
Migrate this existing Replit project off Supabase completely and onto Replit’s built-in SQL database, without breaking current functionality. This is a careful, staged migration with explicit safety gates. The end state is: (1) no Supabase runtime dependencies, (2) no Supabase keys/secrets, (3) all reads/writes go to Replit DB, and (4) app behavior matches or improves compared to today.

NON-NEGOTIABLE CONSTRAINTS:
1) Do not break current production behavior. Prefer additive changes and compatibility layers over risky refactors.
2) No destructive actions without explicit approval. Never drop tables, truncate data, delete buckets, or “clean up” data unless instructed.
3) Work in small, verifiable steps. After each segment, you must:
   - Run the app and tests (or create minimal tests if missing),
   - Provide a verification checklist with pass/fail results,
   - Create a Replit Agent Checkpoint (named clearly),
   - Stop and wait for my confirmation to proceed.
4) Avoid “clever” rewrites. Keep diffs minimal and highly reviewable.
5) You must fully locate and remove Supabase usage by the end, but NOT in the first steps. First we inventory, then introduce Replit DB in parallel, then swap usage, then remove Supabase.
6) Never hardcode secrets or credentials. Use Replit Secrets / environment configuration only.

DELIVERABLES (across all segments):
- A written migration plan file: /docs/migration/supabase-to-replit-db.md
- A DB schema definition and migrations suitable for the app’s current needs.
- A one-time data migration procedure (script + instructions) with verification queries.
- Code changes that move all data access from Supabase to Replit DB.
- A final “Supabase eradication” pass that removes dependencies, env vars, and dead code.

IMPORTANT CONTEXT YOU MUST DISCOVER (do not assume):
- Whether this app uses Supabase for: Postgres data, Auth, Storage, Edge Functions, Realtime, RLS policies.
- What frameworks are used (Next.js/React/Vite/Express/Fastify/etc).
- What ORM/query style is used today (raw SQL, Prisma, Drizzle, etc).
- What environments exist (dev/prod) and how configuration is handled in Replit.

START NOW:
Step A) Create /docs/migration/supabase-to-replit-db.md with:
  - “Current State” placeholders you will fill after scanning the repo
  - “Target State” definition
  - “Risk register” (top 10 risks + mitigation)
  - “Segment-by-segment plan” (Segments 2+)

Step B) Perform a repo-wide audit to identify every Supabase touchpoint:
  - Supabase client initialization
  - All imports of supabase libraries
  - Environment variables referencing Supabase (URLs, keys)
  - Any SQL migrations, schema definitions, seed scripts
  - Auth/session logic
  - Storage uploads/downloads
  - Edge functions/realtime subscriptions
  - RLS assumptions in the application code

Step C) Output an audit report as BOTH:
  1) /docs/migration/supabase-audit.md
  2) A concise summary in chat, including:
     - List of files to edit (grouped by area: auth, data, storage, realtime)
     - Data model inventory (tables/columns as inferred)
     - Risk flags (anything that will be hard to replicate)

SAFETY GATE:
- Do NOT change application behavior in Segment 1.
- Only add documentation files and read-only diagnostics.

END OF SEGMENT 1:
- Provide the audit summary + links to the docs created.
- Create a Checkpoint named: "seg1_supabase_audit_complete"
- STOP and wait for my approval to proceed.
