@System Role: Senior Backend Architect & Integration Specialist
@Objective: Enhance Existing AI Valuation Tool with "eBay Market Scanner" (Strategy A)
@Context: 
We have an EXISTING, functioning AI Piano Valuation Tool (in `server/routes.ts` and `server/ai-valuation-engine.ts`) that currently relies on "S-Curve" math logic. 
WE ARE NOT REPLACING THE TOOL. 
We are ENHANCING it by integrating real-time eBay active listing data as a "Market Audit" layer. 
The system must strictly adhere to the 5,000 calls/day limit via caching and handle high-value items (up to €250k).

@STEP 1: INSTALL DEPENDENCIES
Run: `npm install axios qs node-cache`

@STEP 2: CREATE THE EBAY SERVICE (server/services/ebay.ts)
Create a new service `server/services/ebay.ts` that exports `EbayService`. 
It must be a standalone helper that the existing engine calls.

1. `constructor()`:
   - Initialize `NodeCache` with a TTL of 1 Hour (3600 seconds) to strictly enforce rate limits.

2. `getAccessToken()`:
   - Endpoint: `https://api.ebay.com/identity/v1/oauth2/token`
   - Headers: `Authorization: Basic <Base64(CLIENT_ID:CLIENT_SECRET)>`, `Content-Type: application/x-www-form-urlencoded`
   - Body: `grant_type=client_credentials&scope=https://api.ebay.com/oauth/api_scope/buy.browse`
   - Logic: Cache the token. Check `expires_in` before use.

3. `searchActivePianos(query: string)`:
   - CACHE KEY NORMALIZATION: `const cacheKey = query.toLowerCase().trim();`
   - CACHE CHECK: If `this.cache.get(cacheKey)` exists, return it immediately.
   - Endpoint: `https://api.ebay.com/buy/browse/v1/item_summary/search`
   - Headers: `Authorization: Bearer <TOKEN>`, `X-EBAY-C-MARKETPLACE-ID: EBAY-DE` (EU Market Focus)
   - Params:
     - `q`: `query`
     - `category_ids`: `43376` (Acoustic Pianos)
     - `limit`: `20`
     - `sort`: `price`
     - `filter`: `price:[1000..250000],priceCurrency:EUR,conditionIds:{3000|4000|5000},buyingOptions:{FIXED_PRICE|BEST_OFFER}`
       - (Condition IDs: 3000=Used Excellent, 4000=Used Very Good, 5000=Used Good)
   - Success: Store result in Cache for 1 hour. Return result.
   - Error: Return null (fail silently so the existing tool keeps working).

4. `calculateMarketValue(listings: any[])`:
   - Filter Logic: Exclude "Digital", "Silent", "Cover", "Bench", "Transport", "Miete" (Rental).
   - High-End Logic:
     - If query matches /Steinway|Bösendorfer|Fazioli|Bechstein/i:
       - Take Average of Median 5 listings (Discard cheapest outliers).
     - Else:
       - Take Average of Lowest 5 listings.
   - Formula: `EstimatedValue = AveragePrice * 0.836` (12% negotiation + 5% liquidity).
   - Return: `{ estimatedValue, activeCount, currency: "EUR", strategy: "High-End" | "Mass-Market" }`

@STEP 3: INTEGRATE INTO EXISTING VALUATION ROUTE (server/routes.ts)
Modify the EXISTING `/api/valuation` endpoint. Do NOT delete the old logic.

1. Import `ebayService`.
2. BEFORE running the AI/Math logic, call `await ebayService.searchActivePianos(model)`.
3. LOGIC FLOW:
   - `let finalValue = mathDerivedValue;` (Your existing S-Curve value)
   - `let confidence = "Medium (Historical Algorithm)";`
   - IF (ebayData returns valid value):
     - `finalValue = (mathDerivedValue + ebayData.estimatedValue) / 2;` (Blend them for safety)
     - `confidence = "High (Real-Time Market Data)";`
     - Add to response object: `marketSource: "eBay Active Market (Blended)"`.
   - ELSE:
     - Keep `finalValue` as the S-Curve value.
     - Add to response object: `marketSource: "Historical Algorithm Only"`.

@STEP 4: SECRETS
Ensure code reads `process.env.EBAY_APP_ID` and `process.env.EBAY_CERT_ID`.

@EXECUTE:
Implement this integration now. The priority is STABILITY: The existing tool must never crash if eBay fails; it should just fallback to the math.
